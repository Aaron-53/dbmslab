/************************************************************
*                     SQL Cheatsheet                       *
*                     Core Syntax & Commands               *
************************************************************/

-- ===============================
-- 1. DATABASE OPERATIONS
-- ===============================
-- Create database
CREATE DATABASE db_name;

-- Drop database
DROP DATABASE db_name;

-- Use database
USE db_name; -- MySQL
-- Oracle: Connect via SQL*Plus or SQL Developer

-- Show tables
SHOW TABLES; -- MySQL
SELECT table_name FROM user_tables; -- Oracle

-- ===============================
-- 2. TABLE OPERATIONS (DDL)
-- ===============================
-- Create table
CREATE TABLE employees (
    emp_id NUMBER PRIMARY KEY,
    emp_name VARCHAR2(50) NOT NULL,
    dept_id NUMBER,
    salary NUMBER(10,2),
    hire_date DATE DEFAULT SYSDATE
);

-- Drop table
DROP TABLE employees;

-- Alter table
ALTER TABLE employees
ADD email VARCHAR2(100);

ALTER TABLE employees
MODIFY salary NUMBER(12,2);

ALTER TABLE employees
DROP COLUMN email;

-- ===============================
-- 3. DATA MANIPULATION (DML)
-- ===============================
-- Insert data
INSERT INTO employees (emp_id, emp_name, dept_id, salary)
VALUES (1, 'John', 101, 50000);

-- Insert multiple rows
INSERT ALL
    INTO employees VALUES (2, 'Jane', 102, 60000)
    INTO employees VALUES (3, 'Mike', 101, 55000)
SELECT * FROM dual; -- Oracle only

-- Update data
UPDATE employees
SET salary = salary * 1.1
WHERE dept_id = 101;

-- Delete data
DELETE FROM employees
WHERE emp_id = 3;

-- Select data
SELECT * FROM employees;
SELECT emp_name, salary FROM employees WHERE salary > 50000;
SELECT COUNT(*) FROM employees;

-- ===============================
-- 4. DATA CONTROL (DCL)
-- ===============================
-- Grant permissions
GRANT SELECT, INSERT, UPDATE ON employees TO user1;

-- Revoke permissions
REVOKE INSERT ON employees FROM user1;

-- ===============================
-- 5. TRANSACTION CONTROL (TCL)
-- ===============================
-- Commit transaction
COMMIT;

-- Rollback transaction
ROLLBACK;

-- Savepoint
SAVEPOINT sp1;
ROLLBACK TO sp1;

-- ===============================
-- 6. CONSTRAINTS
-- ===============================
-- Primary Key
emp_id NUMBER PRIMARY KEY

-- Foreign Key
dept_id NUMBER REFERENCES departments(dept_id)

-- Unique
email VARCHAR2(100) UNIQUE

-- Check
salary NUMBER CHECK (salary > 0)

-- Not Null
emp_name VARCHAR2(50) NOT NULL

-- ===============================
-- 7. JOINS
-- ===============================
-- Inner Join
SELECT e.emp_name, d.dept_name
FROM employees e
JOIN departments d ON e.dept_id = d.dept_id;

-- Left Join
SELECT e.emp_name, d.dept_name
FROM employees e
LEFT JOIN departments d ON e.dept_id = d.dept_id;

-- Right Join
SELECT e.emp_name, d.dept_name
FROM employees e
RIGHT JOIN departments d ON e.dept_id = d.dept_id;

-- Full Outer Join
SELECT e.emp_name, d.dept_name
FROM employees e
FULL OUTER JOIN departments d ON e.dept_id = d.dept_id;

-- Cross Join
SELECT e.emp_name, d.dept_name
FROM employees e
CROSS JOIN departments d;

-- Self Join
SELECT e1.emp_name, e2.emp_name AS manager_name
FROM employees e1
JOIN employees e2 ON e1.manager_id = e2.emp_id;

-- ===============================
-- 8. AGGREGATE FUNCTIONS
-- ===============================
SELECT COUNT(*) FROM employees;
SELECT SUM(salary) FROM employees;
SELECT AVG(salary) FROM employees;
SELECT MAX(salary) FROM employees;
SELECT MIN(salary) FROM employees;

-- Group By
SELECT dept_id, AVG(salary)
FROM employees
GROUP BY dept_id;

-- Having
SELECT dept_id, AVG(salary) AS avg_sal
FROM employees
GROUP BY dept_id
HAVING AVG(salary) > 50000;

-- ===============================
-- 9. SUBQUERIES
-- ===============================
-- Scalar subquery
SELECT emp_name, salary
FROM employees
WHERE salary = (SELECT MAX(salary) FROM employees);

-- IN subquery
SELECT emp_name
FROM employees
WHERE dept_id IN (SELECT dept_id FROM departments WHERE location = 'NY');

-- EXISTS subquery
SELECT emp_name
FROM employees e
WHERE EXISTS (SELECT 1 FROM departments d WHERE e.dept_id = d.dept_id);

-- ===============================
-- 10. SET OPERATORS
-- ===============================
-- Union
SELECT emp_name FROM employees
UNION
SELECT emp_name FROM contractors;

-- Union All
SELECT emp_name FROM employees
UNION ALL
SELECT emp_name FROM contractors;

-- Intersect (Oracle only)
SELECT emp_name FROM employees
INTERSECT
SELECT emp_name FROM contractors;

-- Minus (Oracle only)
SELECT emp_name FROM employees
MINUS
SELECT emp_name FROM contractors;

-- ===============================
-- 11. STRING FUNCTIONS
-- ===============================
SELECT UPPER(emp_name) FROM employees;
SELECT LOWER(emp_name) FROM employees;
SELECT SUBSTR(emp_name,1,3) FROM employees;
SELECT LENGTH(emp_name) FROM employees;
SELECT CONCAT(emp_name, ' Jr.') FROM employees;

-- ===============================
-- 12. DATE FUNCTIONS
-- ===============================
SELECT SYSDATE FROM dual; -- Oracle
SELECT CURRENT_DATE FROM dual; -- Oracle
SELECT ADD_MONTHS(SYSDATE, 3) FROM dual;
SELECT MONTHS_BETWEEN(SYSDATE, TO_DATE('2025-01-01','YYYY-MM-DD')) FROM dual;
SELECT TO_CHAR(SYSDATE,'DD-MON-YYYY') FROM dual;

-- ===============================
-- 13. NUMERIC FUNCTIONS
-- ===============================
SELECT ROUND(salary,2) FROM employees;
SELECT TRUNC(salary) FROM employees;
SELECT CEIL(salary) FROM employees;
SELECT FLOOR(salary) FROM employees;
SELECT MOD(salary, 1000) FROM employees;

-- ===============================
-- 14. CONDITIONALS
-- ===============================
-- Case
SELECT emp_name,
       CASE
           WHEN salary > 50000 THEN 'High'
           ELSE 'Low'
       END AS salary_level
FROM employees;

-- Decode (Oracle specific)
SELECT emp_name, DECODE(dept_id, 101,'HR',102,'IT','Other') AS dept_name
FROM employees;

-- ===============================
-- 15. VIEWS
-- ===============================
CREATE VIEW emp_view AS
SELECT emp_name, salary, dept_id
FROM employees
WHERE salary > 50000;

DROP VIEW emp_view;

-- ===============================
-- 16. INDEXES
-- ===============================
CREATE INDEX idx_emp_name ON employees(emp_name);
DROP INDEX idx_emp_name;

-- ===============================
-- 17. SEQUENCES (Oracle)
-- ===============================
CREATE SEQUENCE emp_seq START WITH 1 INCREMENT BY 1;
SELECT emp_seq.NEXTVAL FROM dual;
DROP SEQUENCE emp_seq;

-- ===============================
-- 18. TRIGGERS (Oracle)
-- ===============================
CREATE OR REPLACE TRIGGER trg_salary
BEFORE INSERT OR UPDATE ON employees
FOR EACH ROW
BEGIN
    IF :NEW.salary < 0 THEN
        RAISE_APPLICATION_ERROR(-20001,'Salary cannot be negative');
    END IF;
END;
/

-- ===============================
-- 19. FUNCTIONS (PL/SQL)
-- ===============================
CREATE OR REPLACE FUNCTION get_salary(emp_id NUMBER) RETURN NUMBER IS
    sal NUMBER;
BEGIN
    SELECT salary INTO sal FROM employees WHERE emp_id = get_salary.emp_id;
    RETURN sal;
END;
/

-- ===============================
-- 20. PROCEDURES (PL/SQL)
-- ===============================
CREATE OR REPLACE PROCEDURE increase_salary(p_emp_id NUMBER, p_amount NUMBER) IS
BEGIN
    UPDATE employees
    SET salary = salary + p_amount
    WHERE emp_id = p_emp_id;
    COMMIT;
END;
/




oracle mec69 mec
set serveroutput on
@file.sql


mysql -u mec -p
mec

CREATE OR REPLACE TRIGGER trigger_name
BEFORE | AFTER INSERT | UPDATE | DELETE
ON table_name
FOR EACH ROW
DECLARE
  -- local variables (optional)
BEGIN
  -- logic, e.g., modify :NEW or :OLD values
END;
/

CREATE OR REPLACE PROCEDURE procedure_name (
    param1 IN datatype,
    param2 OUT datatype  -- optional
)
IS
  -- local variable declarations
BEGIN
  -- logic
  -- optionally assign value to OUT parameter
END;
/


NO_DATA_FOUND	SELECT returns no rows
TOO_MANY_ROWS	SELECT returns more than one row
ZERO_DIVIDE	Division by zero
VALUE_ERROR	Invalid conversion, e.g., string to number
DUP_VAL_ON_INDEX	Attempt to insert duplicate in unique column
LOGIN_DENIED	Invalid login attempt
OTHERS	Any other unhandled exception


BEGIN
   -- normal PL/SQL code
EXCEPTION
   WHEN exception_name1 THEN
      -- handle exception 1
   WHEN exception_name2 THEN
      -- handle exception 2
   WHEN OTHERS THEN
      -- handle all other exceptions
END;
/
